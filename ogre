#!/usr/bin/env python
#
# Copyright 2001 Michael K. Johnson <johnsonm@redhat.com>
#
# Ogg-ripping script inspired by autorip, but designed to allow the
# user the opportunity to enter track information and send the info
# off to freedb for the next user.  I wrote it because I got tired
# of autorip not knowing about my less-well-known discs but was
# spoiled by not having to type very much to rip.
#
# pyogg is unapologetically ogg-specific.  Ogg Vorbis sounds better
# than MP3 and is not subject to nasty patents.  Folks with MP3
# players with no ogg capability should use some other ripping
# script, sorry.
#
# pyogg depends on Ben Gertzfield's excellent cddb-py package; check
# http://sourceforge.net/projects/cddb-py/ for a copy.
# RPM packages of cddb-py are available at
# ftp://people.redhat.com/cddb-py/ and probably elsewere.
#
# pyogg is released under the terms of the GNU GPL, version 2 or later.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

pyogg_version = "0.1"
# do not use the real submit address until this has been well-tested
#submit_address = "freedb-submit@freedb.org"
submit_address = "test-submit@freedb.org"
import DiscID, CDDB, cdrom, sys, os, time, re

rip_device="/dev/cdrom"
bitrate=256
# All filenames get substituted with the following variables in context
#   martist   The artist's name encoded as a legal filename component string
#   mtitle    The album title encoded as a legal filename component string
#   category  The category string, which had better be a legal filename
# Additionally, encfile has the following variables available
#   mttitle   The track title encoded as a legal filename component string
#   track     An integer track number within an album
names = {
    # put wav files here
    'wavdir'  : '/tmp/pyogg.wav/',
    # do not rip extra files if dir this full
    'wavcap'  : 700 * 1024 * 1024,
    # temporarily put .oggs here
    'encdir'  : '/tmp/pyogg.enc/%(martist)s/%(mtitle)s/',
    # pattern for file name
    'encfile' : '%(track)02d-%(mttitle)s.ogg',
    # pattern for final dir
    'oggdir'  : '/mnt/ogg/%(category)s/%(martist)s/%(mtitle)s/',
}

class rotator:
    """Very simple text rotator class
    """
    def __init__ (self):
	self.rotator = "/"
    def next (self):
	if self.rotator == "/":
	    self.rotator = "-"
	elif self.rotator == "-":
	    self.rotator = "\\"
	elif self.rotator == "\\":
	    self.rotator = "|"
	elif self.rotator == "|":
	    self.rotator = "/"
	return self.rotator
    def rotate(self, file, fmt):
	file.write(fmt % "" + self.next())
	file.flush()


def mangle(name):
    """Takes a name, returns a legal (and nice...) filename
    """
    return re.sub(r"[^a-zA-Z0-9\-]+", "_", name)

def escapequote(name):
    """Takes a name, escapes anything necessary for the shell
    """
    return re.sub(r'"', r'\"', name)



def waitcd(device=None):
    """Wait for a CD to be inserted into the drive
    """
    r = rotator()
    first=None
    waited=0

    cd = DiscID.open(device)

    while not first:
	try:
	    (first, last) = cdrom.toc_header(cd)
	except cdrom.error, e:
	    if not waited:
		r.rotate(sys.stdout, "Waiting for next disc:  %s")
		waited=1
	    else:
		r.rotate(sys.stdout, "%s")
	    time.sleep(0.5)
    if waited:
	print "found cd"
    return cd

def eject(device=None):
    """Eject the CD
    """
    if device:
	os.system("eject %s" % device)
    else:
	os.system("eject cdrom")

def merge_dicts(dictlist):
    ret = {}
    for dict in dictlist:
	for key in dict.keys():
	    ret[key] = dict[key]
    return ret



def rip_one_track(track, nameinfo):
    pid = os.fork()
    if pid: return pid

    print "Ripping track %d %s" % (track, nameinfo['ttitle'])
    start = time.time()
    os.system("cdparanoia %s -qw %d %s" % (nameinfo['device'],
                                           track, nameinfo['wavname']))
    dur = time.time() - start
    print " Ripped track %d (%dm:%ds) %s" % (track, int(dur/60), int(dur%60),
                                             nameinfo['ttitle'])
    sys.exit(0)

def enc_one_track(track, nameinfo):
    pid = os.fork()
    if pid: return pid

    print "Encoding track %d %s" % (track, nameinfo['ttitle'])
    start = time.time()
    os.system('oggenc -q -b %(bitrate)d -o %(encfile)s -t "%(qttitle)s" -l "%(qtitle)s" -a "%(qartist)s" %(wavname)s 2>/dev/null' % nameinfo)
    os.unlink(nameinfo['wavname'])
    dur = time.time() - start
    print " Encoded track %d (%dm:%ds) %s" % (track, int(dur/60), int(dur%60),
                                             nameinfo['ttitle'])
    sys.exit(0)





def submit_disc_info(cddb_checksum, category, filename):
    """Email a database entry to freedb
    """
    print "Do you wish to submit this info to freedb? (Y/n): ",
    choice = sys.stdin.readline()[:-1]
    if not len(choice) or not choice[0] == "n":
	print "mailing entry to %s" % submit_address
	os.system('mail %s -s "cddb %s %s" < %s' %
			(submit_address, category, cddb_checksum, filename))

def create_disc_info(cd, discId, status):
    """Get data from user, offer to submit data to freedb if status
       indicates a working network connection and database.
       Returns the same 5-tuple as get_disc_info.
    """
    cddb_checksum = discId[0]
    num_tracks = discId[1]
    track_frames = discId[2:-1]
    num_seconds = discId[-1]

    categories = ['blues', 'classical', 'country', 'data',
		  'folk', 'jazz', 'misc', 'newage',
		  'reggae', 'rock', 'soundtrack',]
    category=0
    while not category:
	print "Unrecognized disk.  Please choose category:"
	for i in range(len(categories)):
	    print "%2d) %-10s  " % (i+1, categories[i]),
	    if not (i+1) % 4: print
	if (i+1) % 4: print
	print "> ",
	choice = sys.stdin.readline()
	try:
	    category=int(choice[:-1])
	except:
	    print "Could not understand category choice, please try again."
	    category=0
    category=categories[category-1]

    print "Artist: ",
    artist = sys.stdin.readline()[:-1]
    print "Album title: ",
    title = sys.stdin.readline()[:-1]

    # Create the template file
    pipe = os.popen("mktemp /tmp/pyogg.XXXXXX")
    filename = pipe.readline()[:-1]
    if not len(filename) or pipe.close():
	print "mktemp failed to create temporary file"
	sys.exit(1)
    file = open(filename, "w")
    for trackno in range(num_tracks):
	file.write("TTITLE%d=\n" % trackno)
	file.write("EXTT%d=\n" % trackno)
    file.write("EXTD=\n")
    file.close()

    done = 0
    while not done:

	# Allow the user to fill in the template file
	os.system('[ -z $EDITOR ] && EDITOR=vi; $EDITOR %s' % filename)

	# Parse the template file, checking freedb requirements
	done = 1
	file = open(filename, "r")
	lines = file.readlines()
	file.close()
	elements = {}
	for line in lines:
	    try:
		(var, val) = re.split(r"=", line[:-1], 1)
	    except ValueError:
		var = line[:-2]
	    if elements.has_key(var):
		# can be more than one EXTD
		elements[var]=elements[var]+"\n"+val
	    else:
		elements[var]=val
	for trackno in range(num_tracks):
	    var = "TTITLE%d" % trackno
	    if not elements.has_key(var) or not elements[var]:
		done = 0
		print "%s missing, please fix" % var
		if not elements.has_key(var):
		    file = open(filename, "a")
		    lines = file.write("%s=\n" % var)
		    file.close()
	if not done:
	    print "Press return to invoke editor, control-C to bail out...",
	    sys.stdout.flush()
	    sys.stdin.read()

    print elements
    # Write the real file
    tracklist = []
    tracktitles = {}
    for trackno in range(num_tracks):
	tracktitles[trackno+1] = elements["TTITLE%d" % trackno]
	tracklist.append(trackno+1)
    file = open(filename, "w")
    file.write("# xmcd\n#\n# Track frame offsets:\n")
    print track_frames
    for track in tracklist:
	print track
	file.write("#\t%d\n" % track_frames[track-1])
    file.write("#\n# Disc length: %d seconds\n#\n" % num_seconds)
    file.write("# Revision: 1\n") # FIXME when we can send in updates
    file.write("# Submitted via: pyogg %s\n#\n" % pyogg_version)
    file.write("DISCID=%08x\n" % int(cddb_checksum))
    file.write("DTITLE=%s / %s\n" % (artist, title))
    for track in tracklist:
	file.write("TTITLE%d=%s\n" % (track-1, tracktitles[track]))
    for line in re.split("\n", elements["EXTD"]):
	file.write("EXTD=%s\n" % line)
    for track in tracklist:
	if elements.has_key("EXTT%d" % (track-1)):
	    file.write("EXTT%d=%s\n" % (track-1, elements["EXTT%d" % (track-1)]))
	else:
	    file.write("EXTT%d=\n")
    if elements.has_key("PLAYORDER"):
	file.write("PLAYORDER=%s\n" % elements["PLAYORDER"])
    else:
	file.write("PLAYORDER=\n")
    file.close()

    if status == 202:
	submit_disc_info(cddb_checksum, category, filename)
    return (artist, title, category, tracklist, tracktitles)


def choose_disc_info(list, status):
    """Let user choose from database hits.  Unfortunately, freedb
       sometimes returns a status of multiple entries with a list
       of only one entry...
       If status == 211, the match is inexact; offer to send in an
       updated entry with the new discid whatever option is chosen.
       Returns a dictionary in every case.
    """
    if len(list) == 1:
	return list[0]
    # FIXME: send in new entries for inexact entries
    # FIXME: maybe choose explicitly?
    # for now just choose the first entry
    #print "found ", list
    #print "defaulting to first list entry for now"
    return list[0]


def get_disc_info(cd):
    """Get disc info from freedb if possible, otherwise from user
    """
    discId = DiscID.disc_id(cd)
    (status, discInfo) = CDDB.query(discId)
    if status == 210 or status == 211 or type(discInfo) == type([]):
	discInfo = choose_disc_info(discInfo, status)
    elif not status == 200:
	return create_disc_info(cd, discId, status)

    discTitle = re.split(r"\s+/\s+", discInfo['title'], 1)
    artist = discTitle[0]
    if len(discTitle) == 1:
	title = discTitle[0]
    else:
	title = discTitle[1]

    (status, trackInfo) = CDDB.read(discInfo['category'], discInfo['disc_id'])
    if status == 417:
	print "Server: Access limit exceeded"
	return (None, None, None, None, None)
    elif status == 409 or status == 403 or status == 402:
	print "Server: Server error %d" % status
	return (None, None, None, None, None)
    elif status == 401:
	print "Server: Specified entry not found"
	print "That's funny, we found it a second ago!"
	return (None, None, None, None, None)

    tt = re.compile(r"TTITLE(?P<track>[0-9]+)")
    tracktitles = {}
    for key in trackInfo.keys():
	track = tt.search(key)
	if track:
	    tracktitles[int(track.group('track'))+1] = trackInfo[key]
    tracklist = tracktitles.keys()
    tracklist.sort()
    return (artist, title, discInfo['category'], tracklist, tracktitles)


def do_one_disc():
    """Rip one disk
    """
    cd = waitcd(rip_device)
    (artist, title, category, tracklist, tracktitles) = get_disc_info(cd)
    cd.close()
    if not artist:
	print "OK, let's just skip that one then, shall we?"
	eject(rip_device)
	return

    nameinfo = {'artist':artist,
		'martist':mangle(artist),
		'qartist':escapequote(artist),
	        'title':title,
	        'mtitle':mangle(title),
	        'qtitle':escapequote(title),
	        'category':category}
    nameinfos = {}

    wavdir = names['wavdir'] % nameinfo
    encdir = names['encdir'] % nameinfo
    oggdir = names['oggdir'] % nameinfo
    os.system("mkdir -p %s" % wavdir)
    os.system("mkdir -p %s" % encdir)

    print "Title: %s" % title
    print "Artist: %s" % artist
    for track in tracklist:
	print "\t%d: %s" % (track, tracktitles[track])
	nameinfos[track] = merge_dicts((names, nameinfo,
	    {'track'   : track,
	     'ttitle'  : tracktitles[track],
	     'mttitle' : mangle(tracktitles[track]),
	     'qttitle' : escapequote(tracktitles[track]),
	     'wavname' : "%s/%s%d" % (names['wavdir'] % nameinfo, "track", track)}
	    ))
	encfile = names['encfile'] % nameinfos[track]
	nameinfos[track]['encfile'] = "%s/%s" % (encdir, encfile)

    rip_pending = tracklist[:]
    enc_pending = []
    rip_pid = 0
    enc_pid = 0
    ripping = 0
    encoding = 0

    while rip_pending or enc_pending:
	if rip_pending and not ripping:
	    rip = rip_pending.pop(0)
	    rip_pid = rip_one_track(rip, nameinfos[rip])
	    ripping = rip
	if enc_pending and not encoding:
	    enc = enc_pending.pop(0)
	    enc_pid = enc_one_track(enc, nameinfos[enc])
	    encoding = enc
	(finished, status) = os.wait()
	if finished == rip_pid:
	    enc_pending.append(rip)
	    ripping = 0
	    if not rip_pending:
		eject(rip_device)
	elif finished == enc_pid:
	    encoding = 0

    os.system("mkdir -p %s" % oggdir)
    os.system("mv %s/* %s" % (encdir, oggdir))





if rip_device:
    names['device'] = "-d %s" % rip_device
else:
    names['device'] = ""
names['bitrate'] = bitrate

try:
    while 1:
	do_one_disc()
except KeyboardInterrupt:
    print
    sys.exit (0)
