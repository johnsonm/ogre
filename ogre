#!/usr/bin/env python
#
# Copyright 2001, 2004 Michael K. Johnson <a1237+ogre@danlj.org>
#
# Ogg-ripping script inspired by autorip, but designed to allow the
# user the opportunity to enter track information and send the info
# off to freedb for the next user.  I wrote it because I got tired
# of autorip not knowing about my less-well-known discs but was
# spoiled by not having to type very much to rip.
#
# ogre is unapologetically ogg-specific.  Ogg Vorbis sounds better
# than MP3 and is not subject to nasty patents.  Folks with MP3
# players with no ogg capability should use some other ripping
# script, sorry.
#
# ogre depends on Ben Gertzfield's excellent cddb-py package; check
# http://sourceforge.net/projects/cddb-py/ for a copy.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# A copy of the GNU General Public License can be found in the
# COPYING file that accompanied this distribution

import DiscID, CDDB, cdrom, sys, os, time, re

ogre_version = "0.5"
# do not use the real submit address until this has been well-tested
#submit_address = "freedb-submit@freedb.org"
submit_address = "test-submit@freedb.org"

# interactive=1 says go ahead and ask a few questions when confused
# interactive=0 says only ask questions when there is no alternative
interactive=1
# choose the device which you will be putting the CDs in
rip_device="/dev/cdrom"
# select bitrate from the set: 112, 128, 160, 192, 256, 350
bitrate=256
# All filenames get substituted with the following variables in context
#   martist   The artist's name encoded as a legal filename component string
#   mtitle    The album title encoded as a legal filename component string
#   category  The category string, which had better be a legal filename
# Additionally, encfile has the following variables available
#   mttitle   The track title encoded as a legal filename component string
#   track     An integer track number within an album
names = {
    # put wav files here
    'wavdir'  : '/tmp/ogre.wav/',
    # do not rip extra files if dir this full (not used yet)
    'wavcap'  : 700 * 1024 * 1024,
    # temporarily put .oggs here
    'encdir'  : '/tmp/ogre.enc/%(martist)s/%(mtitle)s/',
    # pattern for file name
    'encfile' : '%(track)02d-%(mttitle)s.ogg',
    # pattern for final dir
    'oggdir'  : '/data/ogg/%(category)s/%(martist)s/%(mtitle)s/',
}

class rotator:
    """Very simple text rotator class
    """
    def __init__ (self):
	self.rotator = "/"
    def next (self):
	if self.rotator == "/":
	    self.rotator = "-"
	elif self.rotator == "-":
	    self.rotator = "\\"
	elif self.rotator == "\\":
	    self.rotator = "|"
	elif self.rotator == "|":
	    self.rotator = "/"
	return self.rotator
    def rotate(self, file, fmt):
	file.write(fmt % "" + self.next())
	file.flush()


def mangle(name):
    """Takes a name, returns a legal (and nice...) filename
    """
    return re.sub(r"[^a-zA-Z0-9\-]+", "_", name)

def escapequote(name):
    """Takes a name, escapes anything necessary for strings
       quoted by '"' characters in the shell
    """
    return re.sub(r'"', r'\"', name)

def hms(seconds):
    ret = ""
    hours = int(seconds / 3600)
    minutes = int((seconds % 3600) / 60)
    seconds = seconds % 60
    if hours:   ret = ret + "%dh" % hours
    if minutes: ret = ret + "%dm" % minutes
    if seconds: ret = ret + "%ds" % seconds
    return ret




def eject(device=None):
    """Eject the CD
    """
    if device:
	os.system("eject %s" % device)
    else:
	os.system("eject cdrom")

def waitcd(device=None):
    """Wait for a CD to be inserted into the drive
    """
    r = rotator()
    first=None
    waited=0
    if not device:
	device=rip_device

    cd = DiscID.open(device)

    while not first:
	try:
	    (first, last) = cdrom.toc_header(cd)
	except cdrom.error, e:
	    if not waited:
		cd.close()
		eject(device)
		cd = DiscID.open(device)
		r.rotate(sys.stdout, "Waiting for next disc:  %s")
		waited=1
	    else:
		r.rotate(sys.stdout, "%s")
	    time.sleep(0.5)
    if waited:
	print "found cd"
    return cd

def merge_dicts(dictlist):
    ret = {}
    for dict in dictlist:
	for key in dict.keys():
	    ret[key] = dict[key]
    return ret



def rip_one_track(track, nameinfo):
    pid = os.fork()
    if pid: return pid

    print "Ripping track %d %s" % (track, nameinfo['ttitle'])
    start = time.time()
    os.system("cdparanoia %s -qw %d %s" % (nameinfo['device'],
                                           track, nameinfo['wavname']))
    dur = time.time() - start
    print " Ripped track %d (%s) %s" % (track, hms(dur), nameinfo['ttitle'])
    sys.exit(0)

def enc_one_track(track, nameinfo):
    pid = os.fork()
    if pid: return pid

    print "Encoding track %d %s" % (track, nameinfo['ttitle'])
    start = time.time()
    os.system('oggenc -Q -b %(bitrate)d -o %(encfile)s -t "%(qttitle)s" -l "%(qtitle)s" -a "%(qartist)s" %(wavname)s 2>/dev/null' % nameinfo)
    os.unlink(nameinfo['wavname'])
    dur = time.time() - start
    print " Encoded track %d (%s) %s" % (track, hms(dur), nameinfo['ttitle'])
    sys.exit(0)





def submit_disc_info(cddb_checksum, category, tracklist, tracktitles,
		     track_frames, num_seconds, artist, title, elements,
		     revision, filename):
    """Email a database entry to freedb
    """
    print "Do you wish to submit this info to freedb? (Y/n): ",
    choice = sys.stdin.readline()[:-1]
    if not len(choice) or not choice[0] == "n":
	# OK, time to write a real database entry
	file = open(filename, "w")
	file.write("# xmcd\n#\n# Track frame offsets:\n")
	for track in tracklist:
	    file.write("#\t%d\n" % track_frames[track-1])
	file.write("#\n# Disc length: %d seconds\n#\n" % num_seconds)
	file.write("# Revision: %d\n" % revision)
	file.write("# Submitted via: ogre %s\n#\n" % ogre_version)
	file.write("DISCID=%08x\n" % int(cddb_checksum))
	file.write("DTITLE=%s / %s\n" % (artist, title))
	for track in tracklist:
	    file.write("TTITLE%d=%s\n" % (track-1, tracktitles[track]))
	for line in re.split("\n", elements["EXTD"]):
	    file.write("EXTD=%s\n" % line)
	for track in tracklist:
	    if elements.has_key("EXTT%d" % (track-1)):
		file.write("EXTT%d=%s\n" % (track-1, elements["EXTT%d" % (track-1)]))
	    else:
		file.write("EXTT%d=\n" % (track-1))
	if elements.has_key("PLAYORDER"):
	    file.write("PLAYORDER=%s\n" % elements["PLAYORDER"])
	else:
	    file.write("PLAYORDER=\n")
	file.close()
	print "mailing entry to %s" % submit_address
	os.system('mail %s -s "cddb %s %s" < %s' %
			(submit_address, category, cddb_checksum, filename))


def create_disc_info(cd, discId, status, tracktimes):
    """Get data from user, offer to submit data to freedb if status
       indicates a working network connection and database.
       Returns the same 5-tuple as get_disc_info.
    """
    cddb_checksum = discId[0]
    num_tracks = discId[1]
    track_frames = discId[2:-1]
    num_seconds = discId[-1]

    categories = ['blues', 'classical', 'country', 'data',
		  'folk', 'jazz', 'misc', 'newage',
		  'reggae', 'rock', 'soundtrack',]
    category=0
    while not category:
	print "Unrecognized disk.  Please choose category:"
	for i in range(len(categories)):
	    print "%2d) %-10s  " % (i+1, categories[i]),
	    if not (i+1) % 4: print
	if (i+1) % 4: print
	print "> ",
	choice = sys.stdin.readline()
	try:
	    category=int(choice[:-1])
	except:
	    print "Could not understand category choice, please try again."
	    category=0
    category=categories[category-1]

    print "Artist: ",
    artist = sys.stdin.readline()[:-1]
    print "Album title: ",
    title = sys.stdin.readline()[:-1]

    # Create the template file
    pipe = os.popen("mktemp /tmp/ogre.XXXXXX")
    filename = pipe.readline()[:-1]
    if not len(filename) or pipe.close():
	print "mktemp failed to create temporary file"
	sys.exit(1)
    file = open(filename, "w")
    file.write("Artist=%s\nAlbumTitle=%s\n" % (artist,title))
    for trackno in range(num_tracks):
	file.write("TTITLE%d=\n" % trackno)
	# Users probably don't care about EXTT
	#file.write("EXTT%d=\n" % trackno)
    file.write("EXTD=\n")
    file.close()

    done = 0
    while not done:

	# Allow the user to fill in the template file
	os.system('[ -z $EDITOR ] && EDITOR=vi; $EDITOR %s' % filename)

	# Parse the template file, checking freedb requirements
	done = 1
	file = open(filename, "r")
	lines = file.readlines()
	file.close()
	elements = {}
	for line in lines:
	    try:
		(var, val) = re.split(r"=", line[:-1], 1)
	    except ValueError:
		var = line[:-2]
	    if elements.has_key(var):
		# can be more than one EXTD
		elements[var]=elements[var]+"\n"+val
	    else:
		elements[var]=val
	for trackno in range(num_tracks):
	    var = "TTITLE%d" % trackno
	    if not elements.has_key(var) or not elements[var]:
		done = 0
		print "%s missing, please fix" % var
		if not elements.has_key(var):
		    file = open(filename, "a")
		    lines = file.write("%s=\n" % var)
		    file.close()
	if not done:
	    print "Press return to invoke editor, control-C to bail out...",
	    sys.stdout.flush()
	    sys.stdin.read()
    tracklist = []
    tracktitles = {}
    for trackno in range(num_tracks):
	tracktitles[trackno+1] = elements["TTITLE%d" % trackno]
	tracklist.append(trackno+1)

    # pick up any changes to artist/title info
    artist = elements["Artist"]
    title = elements["AlbumTitle"]

    if status == 202:
	submit_disc_info(cddb_checksum, category, tracklist, tracktitles,
			 track_frames, num_seconds, artist, title, elements,
			 1, filename)
    os.unlink(filename)
    return (artist, title, category, tracklist, tracktitles, tracktimes)


def choose_disc_info(list, cd, discId, status, tracktimes):
    """Let user choose from database hits.  Unfortunately, freedb
       sometimes returns a status of multiple entries with a list
       of only one entry...
       If status == 211, the match is inexact; offer to send in an
       updated entry with the new discid whatever option is chosen.
       Returns a tuple
         The first element is a discInfo dictionary
	 The second is None or a list returned from create_disc_info
    """
    if len(list) == 1:
	return (list[0], None)
    # FIXME: send in new update entries for inexact matches?

    if interactive: item = 0
    else: item = 1

    while not item:
	print "Please choose one of the following entries:"
	for i in range(len(list)):
	    print "%2d) %10s: %s" % (i+1, list[i]["category"], list[i]["title"])
	print "98) Urk, please skip this CD"
	print "99) None of the above, let me enter the data manually"
	print "> ",
	try:
	    item=int(sys.stdin.readline()[:-1])
	    if item == 98:
		return (None, None)
	    if item == 99:
		return (None, create_disc_info(cd, discId, status, tracktimes))
	    if item-1 not in range(len(list)):
		print "%d not in range, please try again." % item
		item=0
	except KeyboardInterrupt:
	    return (None, None)
	except:
	    print "Not a legal integer value, please try again."
	    item=0

    return (list[item-1], None)


def get_disc_info(cd):
    """Get disc info from freedb if possible, otherwise from user
       Returns artist (string), title (string), category (string),
       tracklist (int list), tracktitles(string dict, int key),
       tracktimes (int array)
    """
    discId = DiscID.disc_id(cd)

    # set up tracktimes
    num_tracks = discId[1]
    track_frames = discId[2:-1]
    num_seconds = discId[-1]
    tracktimes = ['dummy'] # 1-based trackno where this is used
    timecount = 0
    for frameno in range(num_tracks):
	if frameno < (num_tracks-1):
	    thistime = (track_frames[frameno+1]-track_frames[frameno])/75
	    timecount = timecount + thistime
	    tracktimes.append(thistime)
	else:
	    tracktimes.append(num_seconds-timecount)

    (status, discInfo) = CDDB.query(discId, client_name="ogre",
				    client_version=ogre_version)
    if status == 210 or status == 211 or type(discInfo) == type([]):
	(discInfo, ret) = choose_disc_info(discInfo, cd, discId, status, tracktimes)
	if ret: return ret
	if not discInfo: return (None, None, None, None, None, None)
    elif not status == 200:
	return create_disc_info(cd, discId, status, tracktimes)

    discTitle = re.split(r"\s+/\s+", discInfo['title'], 1)
    artist = discTitle[0]
    if len(discTitle) == 1:
	title = discTitle[0]
    else:
	title = discTitle[1]

    (status, trackInfo) = CDDB.read(discInfo['category'], discInfo['disc_id'],
				     client_name="ogre",
				     client_version=ogre_version)
    if status == 417:
	print "Server: Access limit exceeded"
	return (None, None, None, None, None, None)
    elif status == 409 or status == 403 or status == 402:
	print "Server: Server error %d" % status
	return (None, None, None, None, None, None)
    elif status == 401:
	print "Server: Specified entry not found"
	print "That's funny, we found it a second ago!"
	return (None, None, None, None, None, None)

    tt = re.compile(r"TTITLE(?P<track>[0-9]+)")
    tracktitles = {}
    for key in trackInfo.keys():
	track = tt.search(key)
	if track:
	    tracktitles[int(track.group('track'))+1] = trackInfo[key]
    tracklist = tracktitles.keys()
    tracklist.sort()
    return (artist, title, discInfo['category'],
	    tracklist, tracktitles, tracktimes)


def do_one_disc():
    """Rip one disk
    """
    cd = waitcd(rip_device)
    (artist, title, category, tracklist, tracktitles, tracktimes) = get_disc_info(cd)
    cd.close()
    if not artist:
	print "OK, let's just skip that one then, shall we?"
	eject(rip_device)
	return

    nameinfo = {'artist':artist,
		'martist':mangle(artist),
		'qartist':escapequote(artist),
	        'title':title,
	        'mtitle':mangle(title),
	        'qtitle':escapequote(title),
	        'category':category}
    nameinfos = {}

    wavdir = names['wavdir'] % nameinfo
    encdir = names['encdir'] % nameinfo
    oggdir = names['oggdir'] % nameinfo
    os.system("mkdir -p %s" % wavdir)
    os.system("mkdir -p %s" % encdir)

    print "Title: %s" % title
    print "Artist: %s" % artist
    for track in tracklist:
	print "\t%d: %s (%s)" % (track, tracktitles[track], hms(tracktimes[track]))
	nameinfos[track] = merge_dicts((names, nameinfo,
	    {'track'   : track,
	     'ttitle'  : tracktitles[track],
	     'mttitle' : mangle(tracktitles[track]),
	     'qttitle' : escapequote(tracktitles[track]),
	     'wavname' : "%s/%s%d" % (names['wavdir'] % nameinfo, "track", track)}
	    ))
	encfile = names['encfile'] % nameinfos[track]
	nameinfos[track]['encfile'] = "%s/%s" % (encdir, encfile)

    rip_pending = tracklist[:]
    enc_pending = []
    rip_pid = 0
    enc_pid = 0
    ripping = 0
    encoding = 0

    while rip_pending or enc_pending:
	if rip_pending and not ripping:
	    rip = rip_pending.pop(0)
	    rip_pid = rip_one_track(rip, nameinfos[rip])
	    ripping = rip
	if enc_pending and not encoding:
	    enc = enc_pending.pop(0)
	    enc_pid = enc_one_track(enc, nameinfos[enc])
	    encoding = enc
	(finished, status) = os.wait()
	if finished == rip_pid:
	    enc_pending.append(rip)
	    ripping = 0
	    if not rip_pending:
		eject(rip_device)
	elif finished == enc_pid:
	    encoding = 0

    os.system("mkdir -p %s" % oggdir)
    os.system("mv %s/* %s" % (encdir, oggdir))





if rip_device:
    names['device'] = "-d %s" % rip_device
else:
    names['device'] = ""
names['bitrate'] = bitrate

try:
    while 1:
	do_one_disc()
except KeyboardInterrupt:
    print
    sys.exit (0)
